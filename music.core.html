
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>music.core package &#8212; Well the music package name? Yes? 0.1.beta documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1.beta',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="music-core-package">
<h1>music.core package<a class="headerlink" href="#music-core-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-music.core.classes">
<span id="music-core-classes-module"></span><h2>music.core.classes module<a class="headerlink" href="#module-music.core.classes" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="music.core.classes.Being">
<em class="property">class </em><code class="descclassname">music.core.classes.</code><code class="descname">Being</code><a class="headerlink" href="#music.core.classes.Being" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<dl class="method">
<dt id="music.core.classes.Being.addSeq">
<code class="descname">addSeq</code><span class="sig-paren">(</span><em>sequence</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.classes.Being.addSeq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="music.core.classes.Being.freeze">
<code class="descname">freeze</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#music.core.classes.Being.freeze" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="music.core.classes.Being.howl">
<code class="descname">howl</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#music.core.classes.Being.howl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="music.core.classes.Being.mkArray">
<code class="descname">mkArray</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#music.core.classes.Being.mkArray" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="music.core.classes.Being.render">
<code class="descname">render</code><span class="sig-paren">(</span><em>nn</em>, <em>fn=False</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.classes.Being.render" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="music.core.classes.Being.setPar">
<code class="descname">setPar</code><span class="sig-paren">(</span><em>par='f'</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.classes.Being.setPar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="music.core.classes.Being.setPerms">
<code class="descname">setPerms</code><span class="sig-paren">(</span><em>perms</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.classes.Being.setPerms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="music.core.classes.Being.setSize">
<code class="descname">setSize</code><span class="sig-paren">(</span><em>ss</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.classes.Being.setSize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="music.core.classes.Being.startBeing">
<code class="descname">startBeing</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#music.core.classes.Being.startBeing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="music.core.classes.Being.stay">
<code class="descname">stay</code><span class="sig-paren">(</span><em>n</em>, <em>method='perm'</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.classes.Being.stay" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="music.core.classes.Being.walk">
<code class="descname">walk</code><span class="sig-paren">(</span><em>n</em>, <em>method='straight'</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.classes.Being.walk" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-music.core.functions">
<span id="music-core-functions-module"></span><h2>music.core.functions module<a class="headerlink" href="#module-music.core.functions" title="Permalink to this headline">¶</a></h2>
<p>This file holds minimal implementations
to avoid repetitions in the
musical pieces of the MASS framework:</p>
<blockquote>
<div><a class="reference external" href="https://github.com/ttm/mass">https://github.com/ttm/mass</a></div></blockquote>
<p>Sounds are represented as arrays of
PCM samples.
Stereo files are represented
by arrays of shape (2, nsamples).</p>
<dl class="docutils">
<dt>See the music Python Package:</dt>
<dd><a class="reference external" href="https://github.com/ttm/music">https://github.com/ttm/music</a></dd>
</dl>
<p>for a usage of these implementations
within a package and derived routines.</p>
<p>See the file HRTF.py, in this same directory,
for the functions that use impulse responses of
Head Related Transfer Functions (HRTFs).</p>
<p>This file is a copy of mass/src/aux/functions.py
imported
in music/utils.py
as
from .functions import *
but it should be integrated into music package more
properly.</p>
<dl class="function">
<dt id="music.core.functions.AD">
<code class="descclassname">music.core.functions.</code><code class="descname">AD</code><span class="sig-paren">(</span><em>d=2</em>, <em>A=20</em>, <em>D=20</em>, <em>S=-5</em>, <em>R=50</em>, <em>trans='exp'</em>, <em>alpha=1</em>, <em>dB=-80</em>, <em>to_zero=1</em>, <em>nsamples=0</em>, <em>sonic_vector=0</em>, <em>fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.AD" title="Permalink to this definition">¶</a></dt>
<dd><p>Synthesize an ADSR envelope.</p>
<p>ADSR (Atack, Decay, Sustain, Release) is a very traditional
loudness envelope in sound synthesis [1].</p>
<dl class="docutils">
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The duration of the envelope in seconds.</dd>
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The duration of the Attack in milliseconds.</dd>
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The duration of the Decay in milliseconds.</dd>
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The Sustain level after the Decay in decibels.
Usually negative.</dd>
<dt>R <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The duration of the Release in milliseconds.</dd>
<dt>trans <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>“exp” for exponential transitions of amplitude 
(linear loudness).
“linear” for linear transitions of amplitude.</dd>
<dt>alpha <span class="classifier-delimiter">:</span> <span class="classifier">scalar or array_like</span></dt>
<dd>An index to make the exponential fade slower or faster [1].
Ignored it transitions=”linear” or alpha=1.
If it is an array_like, it should hold three values to be used
in Attack, Decay and Release.</dd>
<dt>dB <span class="classifier-delimiter">:</span> <span class="classifier">scalar or array_like</span></dt>
<dd>The decibels deviation to reach before using a linear fade
to reach zero amplitude.
If it is an array_like, it should hold two values,
one for Attack and another for Release.
Ignored if trans=”linear”.</dd>
<dt>to_zero <span class="classifier-delimiter">:</span> <span class="classifier">scalar or array_like</span></dt>
<dd>The duration in milliseconds for linearly departing from zero
in the Attack and reaching the value of zero at the end
of the Release.
If it is an array_like, it should hold two values,
one for Attack and another for Release.
Is ignored if trans=”linear”.</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The number of samples of the envelope.
If supplied, d is ignored.</dd>
<dt>sonic_vector <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Samples for the ADSR envelope to be applied to.
If supplied, d and nsamples are ignored.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The sample rate.</dd>
</dl>
<dl class="docutils">
<dt>AD <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A numpy array where each value is a value of
the envelope for the PCM samples if sonic_vector is 0.
If sonic_vector is input,
AD is the sonic vector with the ADSR envelope applied to it.</dd>
</dl>
<p>T : An oscillation of loudness.
L : A loudness transition.
F : A fade in or fade out.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">V</span><span class="p">()</span><span class="o">*</span><span class="n">AD</span><span class="p">())</span>  <span class="c1"># writes a WAV file of a note with ADSR envelope</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span> <span class="p">[</span><span class="n">V</span><span class="p">()</span><span class="o">*</span><span class="n">AD</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">300</span><span class="p">],</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">200</span><span class="p">])]</span> <span class="p">)</span>  <span class="c1"># OR</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span> <span class="p">[</span><span class="n">AD</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">sonic_vector</span><span class="o">=</span><span class="n">V</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">])]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">envelope</span> <span class="o">=</span> <span class="n">AD</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">440</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="mf">10e3</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="mf">5e3</span><span class="p">)</span>  <span class="c1"># a lengthy envelope</span>
</pre></div>
</div>
<p>Cite the following article whenever you use this function.</p>
<table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Fabbri, Renato, et al. “Musical elements in the</td></tr>
</tbody>
</table>
<p>discrete-time representation of sound.” arXiv preprint arXiv:abs/1412.6853 (2017)</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.ADS">
<code class="descclassname">music.core.functions.</code><code class="descname">ADS</code><span class="sig-paren">(</span><em>d=2</em>, <em>A=20</em>, <em>D=20</em>, <em>S=-5</em>, <em>R=50</em>, <em>trans='exp'</em>, <em>alpha=1</em>, <em>dB=-80</em>, <em>to_zero=1</em>, <em>nsamples=0</em>, <em>sonic_vector=0</em>, <em>fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.ADS" title="Permalink to this definition">¶</a></dt>
<dd><p>A shorthand to make an ADSR envelope for a stereo sound.</p>
<p>See ADSR() for more information.</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.AM">
<code class="descclassname">music.core.functions.</code><code class="descname">AM</code><span class="sig-paren">(</span><em>d=2</em>, <em>fm=50</em>, <em>a=0.4</em>, <em>taba=array([ 0.</em>, <em>0.0003835</em>, <em>0.00076699</em>, <em>...</em>, <em>-0.00115049</em>, <em>-0.00076699</em>, <em>-0.0003835 ])</em>, <em>nsamples=0</em>, <em>sonic_vector=0</em>, <em>fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.AM" title="Permalink to this definition">¶</a></dt>
<dd><p>Synthesize an AM envelope or apply it to a sound.</p>
<p>Set fm=0 or a=0 for a constant envelope with value 1.
An AM is a linear oscillatory pattern of amplitude [1].</p>
<dl class="docutils">
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The duration of the envelope in seconds.</dd>
<dt>fm <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The frequency of the modultar in Hertz.</dd>
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">scalar in [0,1]</span></dt>
<dd>The maximum deviation of amplitude of the AM.</dd>
<dt>tabm <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The table with the waveform for the tremolo oscillatory pattern.</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The number of samples of the envelope. If supplied, d is ignored.</dd>
<dt>sonic_vector <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Samples for the tremolo to be applied to.
If supplied, d and nsamples are ignored.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The sample rate.</dd>
</dl>
<dl class="docutils">
<dt>T <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A numpy array where each value is a PCM sample
of the envelope.
if sonic_vector is 0.
If sonic_vector is input,
T is the sonic vector with the AM applied to it.</dd>
</dl>
<p>V : A musical note with an oscillation of pitch.
FM : A linear oscillation of fundamental frequency.
T : A tremolo, an oscillation of loudness.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">V</span><span class="p">()</span><span class="o">*</span><span class="n">AM</span><span class="p">())</span>  <span class="c1"># writes a WAV file of a note with tremolo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span> <span class="p">[</span><span class="n">V</span><span class="p">()</span><span class="o">*</span><span class="n">AM</span><span class="p">(</span><span class="n">fm</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">60</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">])]</span> <span class="p">)</span>  <span class="c1"># OR</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span> <span class="p">[</span><span class="n">AM</span><span class="p">(</span><span class="n">fm</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">sonic_vector</span><span class="o">=</span><span class="n">V</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">60</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">])]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">envelope2</span> <span class="o">=</span> <span class="n">AM</span><span class="p">(</span><span class="mi">440</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>  <span class="c1"># a lengthy envelope</span>
</pre></div>
</div>
<p>In the MASS framework implementation, for obtaining a sound with a tremolo (or AM),
the tremolo pattern is considered separately from a synthesis of the sound.</p>
<p>The vibrato and FM patterns are considering when synthesizing the sound.</p>
<p>One might want to run this function twice to obtain
a stereo reverberation.</p>
<p>Cite the following article whenever you use this function.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Fabbri, Renato, et al. “Musical elements in the</td></tr>
</tbody>
</table>
<p>discrete-time representation of sound.” arXiv preprint arXiv:abs/1412.6853 (2017)</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.D">
<code class="descclassname">music.core.functions.</code><code class="descname">D</code><span class="sig-paren">(</span><em>f=220, d=2, tab=array([-1.        , -0.99975586, -0.99951172, ..., -0.99951172,        -0.99975586, -1.        ]), x=[-10, 10], y=[1, 1], stereo=True, zeta=0.215, temp=20, nsamples=0, fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.D" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple note with a transition of localization and resulting Doppler effect.</p>
<dl class="docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The frequency of the note in Hertz.</dd>
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The duration of the note in seconds.</dd>
<dt>tab <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The table with the waveform to synthesize the sound.</dd>
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">iterable of scalars</span></dt>
<dd>The starting and ending x positions.</dd>
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">iterable of scalars</span></dt>
<dd>The starting and ending y positions.</dd>
<dt>stereo <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>If True, returns a (2, nsamples) array representing
a stereo sound. Else it returns a simple array
for a mono sound.</dd>
<dt>temp <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The air temperature in Celsius.
(Used to calculate the acoustic velocity.)</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The number of samples in the sound.
If not 0, d is ignored.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The sample rate.</dd>
</dl>
<dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The PCM samples of the resulting sound.</dd>
</dl>
<p><a href="#id21"><span class="problematic" id="id22">D_</span></a> : a note with arbitrary vibratos, transitions of pitch
and transitions of localization.
<a href="#id23"><span class="problematic" id="id24">PV_</span></a> : a note with an arbitrary sequence of pitch transition and a meta-vibrato.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">WS</span><span class="p">(</span><span class="n">D</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">T</span><span class="p">()</span><span class="o">*</span><span class="n">D</span><span class="p">(</span><span class="n">stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
</pre></div>
</div>
<p>Cite the following article whenever you use this function.</p>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Fabbri, Renato, et al. “Musical elements in the</td></tr>
</tbody>
</table>
<p>discrete-time representation of sound.” arXiv preprint arXiv:abs/1412.6853 (2017)</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.D_">
<code class="descclassname">music.core.functions.</code><code class="descname">D_</code><span class="sig-paren">(</span><em>f=[220, 440, 330], d=[[2, 3], [2, 5, 3], [2, 5, 6, 1, 0.4], [4, 6, 1]], fv=[[2, 6, 1], [0.5, 15, 2, 6, 3]], nu=[[2, 1, 5], [4, 3, 7, 10, 3]], alpha=[[1, 1], [1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1]], x=[-10, 10, 5, 3], y=[1, 1, 0.1, 0.1], method=['lin', 'exp', 'lin'], tab=[[array([-1.        , -0.99975586, -0.99951172, ..., -0.99951172,        -0.99975586, -1.        ]), array([-1.        , -0.99975586, -0.99951172, ..., -0.99951172,        -0.99975586, -1.        ])], [array([ 0.        ,  0.0003835 ,  0.00076699, ..., -0.00115049,        -0.00076699, -0.0003835 ]), array([-1.        , -0.99975586, -0.99951172, ..., -0.99951172,        -0.99975586, -1.        ]), array([ 0.        ,  0.0003835 ,  0.00076699, ..., -0.00115049,        -0.00076699, -0.0003835 ])], [array([ 0.        ,  0.0003835 ,  0.00076699, ..., -0.00115049,        -0.00076699, -0.0003835 ]), array([ 0.        ,  0.0003835 ,  0.00076699, ..., -0.00115049,        -0.00076699, -0.0003835 ]), array([ 0.        ,  0.0003835 ,  0.00076699, ..., -0.00115049,        -0.00076699, -0.0003835 ]), array([ 0.        ,  0.0003835 ,  0.00076699, ..., -0.00115049,        -0.00076699, -0.0003835 ]), array([ 0.        ,  0.0003835 ,  0.00076699, ..., -0.00115049,        -0.00076699, -0.0003835 ])]], stereo=True, zeta=0.215, temp=20, nsamples=0, fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.D_" title="Permalink to this definition">¶</a></dt>
<dd><p>A sound with arbitrary meta-vibratos, transitions of frequency and localization.</p>
<dl class="docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">list of lists of scalars</span></dt>
<dd>The frequencies of the note at each end of the transitions.</dd>
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">list of lists of scalars</span></dt>
<dd>The durations of the pitch transitions and then of the 
vibratos and then of the position transitions.</dd>
<dt>fv <span class="classifier-delimiter">:</span> <span class="classifier">list of lists of scalars</span></dt>
<dd>The frequencies of each vibrato.</dd>
<dt>nu <span class="classifier-delimiter">:</span> <span class="classifier">list of lists of scalars</span></dt>
<dd>The maximum deviation of pitch in the vibratos in semitones.</dd>
<dt>alpha <span class="classifier-delimiter">:</span> <span class="classifier">list of lists of scalars</span></dt>
<dd>Indexes to distort the pitch deviations of the transitions
and the vibratos.</dd>
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">list of lists of scalars</span></dt>
<dd>The x positions at each end of the transitions.</dd>
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">list of lists of scalars</span></dt>
<dd>The y positions at each end of the transitions.</dd>
<dt>method <span class="classifier-delimiter">:</span> <span class="classifier">list of strings</span></dt>
<dd>An entry for each transition of location: ‘exp’ for
exponential and ‘lin’ (default) for linear.</dd>
<dt>stereo <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>If True, returns a (2, nsamples) array representing
a stereo sound. Else it returns a simple array
for a mono sound.</dd>
<dt>tab <span class="classifier-delimiter">:</span> <span class="classifier">list of lists of array_likes</span></dt>
<dd>The tables with the waveforms to synthesize the sound
and then for the oscillatory patterns of the vibratos.
All the tables for f should have the same size.</dd>
<dt>zeta <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The distance between the ears in meters.</dd>
<dt>temp <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The air temperature in Celsius.
(Used to calculate the acoustic velocity.)</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The number of samples of the sound.
If supplied, d is not used.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The sample rate.</dd>
</dl>
<dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A numpy array where each value is a PCM sample of the sound.</dd>
</dl>
<p>PV : A note with a glissando and a vibrato.
D : A note with a simple linear transition of location.
PVV : A note with a glissando and two vibratos.
VV : A note with a vibrato with two oscillatory patterns.
N : a basic musical note without vibrato.
V : a musical note with an oscillation of pitch.
T : a tremolo, an oscillation of loudness.
F : fade in and out.
L : a transition of loudness.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">D_</span><span class="p">())</span>  <span class="c1"># writes file with glissandi and vibratos</span>
</pre></div>
</div>
<p>Check the functions above for more information about
how each feature of this function is implemented.</p>
<p>Cite the following article whenever you use this function.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Fabbri, Renato, et al. “Musical elements in the</td></tr>
</tbody>
</table>
<p>discrete-time representation of sound.” arXiv preprint arXiv:abs/1412.6853 (2017)</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.F">
<code class="descclassname">music.core.functions.</code><code class="descname">F</code><span class="sig-paren">(</span><em>d=2</em>, <em>out=True</em>, <em>method='exp'</em>, <em>dB=-80</em>, <em>alpha=1</em>, <em>perc=1</em>, <em>nsamples=0</em>, <em>sonic_vector=0</em>, <em>fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.F" title="Permalink to this definition">¶</a></dt>
<dd><p>A fade in or out.</p>
<p>Implements the loudness transition and asserts that it reaches
zero amplitude.</p>
<dl class="docutils">
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The duration in seconds of the fade.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>If True, the fade is a fade out, else it is a fade in.</dd>
<dt>method <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>“exp” for an exponential transition of amplitude (linear loudness).
“linear” for a linear transition of amplitude.</dd>
<dt>dB <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The decibels from which to reach before using
the linear transition to reach zero.
Not used if method=”linear”.</dd>
<dt>alpha <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>An index to make the exponential fade slower or faster [1].
Ignored it transitions=”linear”.</dd>
<dt>perc <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The percentage of the fade that is linear to assure it reaches zero.
Has no effect if method=”linear”.</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The number of samples of the fade. If supplied, d is ignored.</dd>
<dt>sonic_vector <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Samples for the fade to be applied to.
If supplied, d and nsamples are ignored.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The sample rate. Only used if nsamples and sonic_vector are not supplied.</dd>
</dl>
<dl class="docutils">
<dt>T <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A numpy array where each value is a value of the envelope for the PCM samples.
If sonic_vector is input, T is the sonic vector with the fade applied to it.</dd>
</dl>
<p>AD : An ADSR envelope.
L : A transition of loudness.
<a href="#id25"><span class="problematic" id="id26">L_</span></a> : An envelope with an arbitrary number or loudness transitions.
T : An oscillation of loudness.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">V</span><span class="p">()</span><span class="o">*</span><span class="n">F</span><span class="p">())</span>  <span class="c1"># writes a WAV file with a fade in</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span> <span class="p">[</span><span class="n">V</span><span class="p">()</span><span class="o">*</span><span class="n">F</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;exp&quot;</span><span class="p">,</span> <span class="s2">&quot;exp&quot;</span><span class="p">,</span> <span class="s2">&quot;linear&quot;</span><span class="p">])]</span> <span class="p">)</span>  <span class="c1"># OR</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span> <span class="p">[</span><span class="n">F</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">sonic_vector</span><span class="o">=</span><span class="n">V</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;exp&quot;</span><span class="p">,</span> <span class="s2">&quot;exp&quot;</span><span class="p">,</span> <span class="s2">&quot;linear&quot;</span><span class="p">])]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">envelope</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">perc</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>  <span class="c1"># a lengthy fade in </span>
</pre></div>
</div>
<p>Cite the following article whenever you use this function.</p>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Fabbri, Renato, et al. “Musical elements in the discrete-time representation of sound.” arXiv preprint arXiv:abs/1412.6853 (2017)</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.FIR">
<code class="descclassname">music.core.functions.</code><code class="descname">FIR</code><span class="sig-paren">(</span><em>samples</em>, <em>sonic_vector</em>, <em>freq=True</em>, <em>max_freq=True</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.FIR" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a FIR filter to a sonic_array.</p>
<dl class="docutils">
<dt>samples <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>A sequence of absolute values for the frequencies
(if freq=True) or samples of an impulse response.</dd>
<dt>sonic_vector <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>An one-dimensional array with the PCM samples of
the signal (e.g. sound) for the FIR filter
to be applied to.</dd>
<dt>freq <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>Set to True if samples are frequency absolute values
or False if samples is an impulse response.
If max_freq=True, the separations between the frequencies
are fs/(2*N-2).
If max_freq=False, the separation between the frequencies
are fs/(2*N-1).
Where N is the length of the provided samples.</dd>
<dt>max_freq <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>Set to true if the last item in the samples is related
to the Nyquist frequency fs/2.
Ignored if freq=False.</dd>
</dl>
<p>If freq=True, the samples are the absolute values of
the frequency components.
The phases are set to zero to maintain the phases
of the components of the original signal.</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.FM">
<code class="descclassname">music.core.functions.</code><code class="descname">FM</code><span class="sig-paren">(</span><em>f=220</em>, <em>d=2</em>, <em>fm=100</em>, <em>mu=2</em>, <em>tab=array([-1.</em>, <em>-0.99975586</em>, <em>-0.99951172</em>, <em>...</em>, <em>-0.99951172</em>, <em>-0.99975586</em>, <em>-1.        ])</em>, <em>tabm=array([ 0.</em>, <em>0.0003835</em>, <em>0.00076699</em>, <em>...</em>, <em>-0.00115049</em>, <em>-0.00076699</em>, <em>-0.0003835 ])</em>, <em>nsamples=0</em>, <em>fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.FM" title="Permalink to this definition">¶</a></dt>
<dd><p>Synthesize a musical note with FM synthesis.</p>
<p>Set fm=0 or mu=0 (or use N()) for a note without FM.
A FM is a linear oscillatory pattern of frequency [1].</p>
<dl class="docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The frequency of the note in Hertz.</dd>
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The duration of the note in seconds.</dd>
<dt>fm <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The frequency of the modulator in Hertz.</dd>
<dt>mu <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The maximum deviation of frequency in the modulator in Hertz.</dd>
<dt>tab <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The table with the waveform for the carrier.</dd>
<dt>tabv <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The table with the waveform for the modulator.</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The number of samples in the sound.
If supplied, d is ignored.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The sample rate.</dd>
</dl>
<dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A numpy array where each value is a PCM sample of the note.</dd>
</dl>
<p>N : A basic musical note without vibrato.
V : A musical note with an oscillation of pitch.
T : A tremolo, an oscillation of loudness.
AM : A linear oscillation of amplitude (not linear loudness).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">FM</span><span class="p">())</span>  <span class="c1"># writes a WAV file of a note</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span> <span class="p">[</span><span class="n">FM</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">200</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">FM</span><span class="p">(</span><span class="mi">440</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>In the MASS framework implementation,
for a sound with a vibrato (or FM) to be synthesized using LUT,
the vibrato (or FM)
pattern is considered when performing the lookup calculations.</p>
<p>The tremolo and AM patterns are implemented as separate amplitude envelopes.</p>
<p>Cite the following article whenever you use this function.</p>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Fabbri, Renato, et al. “Musical elements in the</td></tr>
</tbody>
</table>
<p>discrete-time representation of sound.” arXiv preprint arXiv:abs/1412.6853 (2017)</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.IIR">
<code class="descclassname">music.core.functions.</code><code class="descname">IIR</code><span class="sig-paren">(</span><em>sonic_vector</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.IIR" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply an IIR filter to a signal.</p>
<dl class="docutils">
<dt>sonic_vector <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>An one dimensional array representing the signal
(potentially a sound) for the filter to by applied to.</dd>
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">iterable of scalars</span></dt>
<dd>The feedforward coefficients.</dd>
<dt>B <span class="classifier-delimiter">:</span> <span class="classifier">iterable of scalars</span></dt>
<dd>The feedback filter coefficients.</dd>
</dl>
<p>Check [1] to know more about this function.</p>
<p>Cite the following article whenever you use this function.</p>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Fabbri, Renato, et al. “Musical elements in the</td></tr>
</tbody>
</table>
<p>discrete-time representation of sound.”
arXiv preprint arXiv:abs/1412.6853 (2017)</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.L">
<code class="descclassname">music.core.functions.</code><code class="descname">L</code><span class="sig-paren">(</span><em>d=2</em>, <em>dev=10</em>, <em>alpha=1</em>, <em>to=True</em>, <em>method='exp'</em>, <em>nsamples=0</em>, <em>sonic_vector=0</em>, <em>fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.L" title="Permalink to this definition">¶</a></dt>
<dd><p>An envelope for linear or exponential transition of amplitude.</p>
<p>An exponential transition of loudness yields a linean
transition of loudness (theoretically).</p>
<dl class="docutils">
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The duration of the envelope in seconds.</dd>
<dt>dev <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The deviation of the transition.
If method=”exp” the deviation is in decibels.
If method=”linear” the deviation is an amplitude proportion.</dd>
<dt>alpha <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>An index to make the transition slower or faster [1].
Ignored it method=”linear”.</dd>
<dt>to <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>If True, the transition ends at the deviation.
If False, the transition starts at the deviation.</dd>
<dt>method <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>“exp” for exponential transitions of amplitude (linear loudness).
“linear” for linear transitions of amplitude.</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The number of samples of the envelope.
If supplied, d is ignored.</dd>
<dt>sonic_vector <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Samples for the envelope to be applied to.
If supplied, d and nsamples are ignored.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The sample rate.
Only used if nsamples and sonic_vector are not supplied.</dd>
</dl>
<dl class="docutils">
<dt>E <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A numpy array where each value is a value of the envelope 
for the PCM samples.
If sonic_vector is supplied,
ai is the sonic vector with the envelope applied to it.</dd>
</dl>
<p><a href="#id27"><span class="problematic" id="id28">L_</span></a> : An envelope with an arbitrary number of transitions.
F : Fade in and out.
AD : An ADSR envelope.
T : An oscillation of loudness.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">V</span><span class="p">()</span><span class="o">*</span><span class="n">L</span><span class="p">())</span>  <span class="c1"># writes a WAV file of a loudness transition</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span> <span class="p">[</span><span class="n">V</span><span class="p">()</span><span class="o">*</span><span class="n">L</span><span class="p">(</span><span class="n">dev</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;exp&quot;</span><span class="p">,</span> <span class="s2">&quot;exp&quot;</span><span class="p">,</span> <span class="s2">&quot;linear&quot;</span><span class="p">])]</span> <span class="p">)</span>  <span class="c1"># OR</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span> <span class="p">[</span><span class="n">L</span><span class="p">(</span><span class="n">dev</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">sonic_vector</span><span class="o">=</span><span class="n">V</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;exp&quot;</span><span class="p">,</span> <span class="s2">&quot;exp&quot;</span><span class="p">,</span> <span class="s2">&quot;linear&quot;</span><span class="p">])]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">envelope</span> <span class="o">=</span> <span class="n">L</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">dev</span><span class="o">=-</span><span class="mi">80</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># a lengthy fade in </span>
</pre></div>
</div>
<p>Cite the following article whenever you use this function.</p>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Fabbri, Renato, et al. “Musical elements in the discrete-time representation of sound.” arXiv preprint arXiv:abs/1412.6853 (2017)</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.L_">
<code class="descclassname">music.core.functions.</code><code class="descname">L_</code><span class="sig-paren">(</span><em>d=[2, 4, 2], dev=[5, -10, 20], alpha=[1, 0.5, 20], method=['exp', 'exp', 'exp'], nsamples=0, sonic_vector=0, fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.L_" title="Permalink to this definition">¶</a></dt>
<dd><p>An envelope with linear or exponential transitions of amplitude.</p>
<p>See L() for more details.</p>
<dl class="docutils">
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">iterable</span></dt>
<dd>The durations of the transitions in seconds.</dd>
<dt>dev <span class="classifier-delimiter">:</span> <span class="classifier">iterable</span></dt>
<dd>The deviation of the transitions.
If method=”exp” the deviation is in decibels.
If method=”linear” the deviation is an amplitude proportion.</dd>
<dt>alpha <span class="classifier-delimiter">:</span> <span class="classifier">iterable</span></dt>
<dd>Indexes to make the transitions slower or faster [1].
Ignored it method[1]=”linear”.</dd>
<dt>method <span class="classifier-delimiter">:</span> <span class="classifier">iterable</span></dt>
<dd>Methods for each transition.
“exp” for exponential transitions of amplitude (linear loudness).
“linear” for linear transitions of amplitude.</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">interable</span></dt>
<dd>The number of samples of each transition.
If supplied, d is ignored.</dd>
<dt>sonic_vector <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Samples for the envelope to be applied to.
If supplied, d or nsamples is used, the final
sound has the greatest duration of sonic_array
and d (or nsamples) and missing samples are
replaced with silence (if sonic_vector is shorter)
or with a constant value (if d or nsamples yield shorter
sequences).</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The sample rate.
Only used if nsamples and sonic_vector are not supplied.</dd>
</dl>
<dl class="docutils">
<dt>E <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A numpy array where each value is a value of the envelope
for the PCM samples.
If sonic_vector is supplied,
E is the sonic vector with the envelope applied to it.</dd>
</dl>
<p>L : An envelope for a loudness transition.
F : Fade in and out.
AD : An ADSR envelope.
T : An oscillation of loudness.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">V</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span><span class="o">*</span><span class="n">L_</span><span class="p">())</span>  <span class="c1"># writes a WAV file with a loudness transitions</span>
</pre></div>
</div>
<p>Cite the following article whenever you use this function.</p>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Fabbri, Renato, et al. “Musical elements in the discrete-time representation of sound.” arXiv preprint arXiv:abs/1412.6853 (2017)</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.N">
<code class="descclassname">music.core.functions.</code><code class="descname">N</code><span class="sig-paren">(</span><em>f=220</em>, <em>d=2</em>, <em>tab=array([-1.</em>, <em>-0.99975586</em>, <em>-0.99951172</em>, <em>...</em>, <em>-0.99951172</em>, <em>-0.99975586</em>, <em>-1.        ])</em>, <em>nsamples=0</em>, <em>fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.N" title="Permalink to this definition">¶</a></dt>
<dd><p>Synthesize a basic musical note.</p>
<dl class="docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The frequency of the note in Hertz.</dd>
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The duration of the note in seconds.</dd>
<dt>tab <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The table with the waveform to synthesize the sound.</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The number of samples in the sound.
If not 0, d is ignored.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The sample rate.</dd>
</dl>
<dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A numpy array where each value is a PCM sample of the note.</dd>
</dl>
<p>V : A note with vibrato.
T : A tremolo envelope.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">N</span><span class="p">())</span>  <span class="c1"># writes a WAV file of a note</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span> <span class="p">[</span><span class="n">N</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">200</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">N</span><span class="p">(</span><span class="mi">440</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">tab</span><span class="o">=</span><span class="n">Sa</span><span class="p">)</span>
</pre></div>
</div>
<p>In the MASS framework implementation,
for a sound with a vibrato (or FM) to be synthesized using LUT,
the vibrato pattern is considered when performing the lookup calculations.</p>
<p>The tremolo and AM patterns are implemented as separate amplitude envelopes.</p>
<p>Cite the following article whenever you use this function.</p>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Fabbri, Renato, et al. “Musical elements in the</td></tr>
</tbody>
</table>
<p>discrete-time representation of sound.” arXiv preprint arXiv:abs/1412.6853 (2017)</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.N_">
<code class="descclassname">music.core.functions.</code><code class="descname">N_</code><span class="sig-paren">(</span><em>f=220</em>, <em>d=2</em>, <em>phase=0</em>, <em>tab=array([-1.</em>, <em>-0.99975586</em>, <em>-0.99951172</em>, <em>...</em>, <em>-0.99951172</em>, <em>-0.99975586</em>, <em>-1.        ])</em>, <em>nsamples=0</em>, <em>fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.N_" title="Permalink to this definition">¶</a></dt>
<dd><p>Synthesize a basic musical note with a phase.</p>
<p>Is useful in more complex synthesis routines.
For synthesizing a musical note directly,
you probably want to use N() and disconsider
the phase.</p>
<dl class="docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The frequency of the note in Hertz.</dd>
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The duration of the note in seconds.</dd>
<dt>phase <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The phase of the wave in radians.</dd>
<dt>tab <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The table with the waveform to synthesize the sound.</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The number of samples in the sound.
If not 0, d is ignored.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The sample rate.</dd>
</dl>
<dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A numpy array where each value is a PCM sample of the note.</dd>
</dl>
<p>N : A basic note.
V : A note with vibrato.
T : A tremolo envelope.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">N_</span><span class="p">())</span>  <span class="c1"># writes a WAV file of a note</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span> <span class="p">[</span><span class="n">N_</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">200</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">N_</span><span class="p">(</span><span class="mi">440</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">tab</span><span class="o">=</span><span class="n">Sa</span><span class="p">)</span>
</pre></div>
</div>
<p>In the MASS framework implementation,
for a sound with a vibrato (or FM) to be synthesized using LUT,
the vibrato pattern is considered when performing the lookup calculations.</p>
<p>The tremolo and AM patterns are implemented as separate amplitude envelopes.</p>
<p>Cite the following article whenever you use this function.</p>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Fabbri, Renato, et al. “Musical elements in the</td></tr>
</tbody>
</table>
<p>discrete-time representation of sound.” arXiv preprint arXiv:abs/1412.6853 (2017)</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.P">
<code class="descclassname">music.core.functions.</code><code class="descname">P</code><span class="sig-paren">(</span><em>f1=220</em>, <em>f2=440</em>, <em>d=2</em>, <em>alpha=1</em>, <em>tab=array([ 0.</em>, <em>0.0003835</em>, <em>0.00076699</em>, <em>...</em>, <em>-0.00115049</em>, <em>-0.00076699</em>, <em>-0.0003835 ])</em>, <em>method='exp'</em>, <em>nsamples=0</em>, <em>fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.P" title="Permalink to this definition">¶</a></dt>
<dd><p>A note with a pitch transition: a glissando.</p>
<dl class="docutils">
<dt>f1 <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The starting frequency.</dd>
<dt>f2 <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The final frequency.</dd>
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The duration of the sound in seconds.</dd>
<dt>alpha <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>An index to begin the transition faster or slower. 
If alpha != 1, the transition is not of linear pitch.</dd>
<dt>tab <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The table with the waveform to synthesize the sound.</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The number of samples of the sound.
If supplied, d is not used.</dd>
<dt>method <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>“exp” for an exponential transition of frequency
(linear pitch).
“lin” for a linear transition of amplitude.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The sample rate.</dd>
</dl>
<dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A numpy array where each value is a PCM sample of the sound.</dd>
</dl>
<p>N : A basic musical note without vibrato or pitch transition.
V : A musical note with an oscillation of pitch.
T : A tremolo, an oscillation of loudness.
L : A transition of loudness.
F : Fade in or out.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">P</span><span class="p">())</span>  <span class="c1"># writes file with a glissando</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span> <span class="p">[</span><span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">220</span><span class="p">,</span> <span class="mi">440</span><span class="p">,</span> <span class="mi">4000</span><span class="p">],</span> <span class="p">[</span><span class="mi">440</span><span class="p">,</span> <span class="mi">220</span><span class="p">,</span> <span class="mi">220</span><span class="p">])]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># writes a file with glissandi</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.PV">
<code class="descclassname">music.core.functions.</code><code class="descname">PV</code><span class="sig-paren">(</span><em>f1=220</em>, <em>f2=440</em>, <em>d=2</em>, <em>fv=4</em>, <em>nu=2</em>, <em>alpha=1</em>, <em>alphav=1</em>, <em>tab=array([ 0.</em>, <em>0.0003835</em>, <em>0.00076699</em>, <em>...</em>, <em>-0.00115049</em>, <em>-0.00076699</em>, <em>-0.0003835 ])</em>, <em>tabv=array([ 0.</em>, <em>0.0003835</em>, <em>0.00076699</em>, <em>...</em>, <em>-0.00115049</em>, <em>-0.00076699</em>, <em>-0.0003835 ])</em>, <em>nsamples=0</em>, <em>fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.PV" title="Permalink to this definition">¶</a></dt>
<dd><p>A note with a pitch transition (a glissando) and a vibrato.</p>
<dl class="docutils">
<dt>f1 <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The starting frequency.</dd>
<dt>f2 <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The final frequency.</dd>
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The duration of the sound in seconds.</dd>
<dt>fv <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The frequency of the vibrato oscillations in Hertz.</dd>
<dt>nu <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The maximum deviation of pitch of the vibrato in semitones.</dd>
<dt>alpha <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>An index to begin the transitions faster or slower. 
If alpha != 1, the transition is not of linear pitch.</dd>
<dt>alphav <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>An index to distort the pitch deviation of the vibrato.</dd>
<dt>tab <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The table with the waveform to synthesize the sound.</dd>
<dt>tabv <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The table with the waveform for the vibrato oscillatory pattern.</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The number of samples of the sound.
If supplied, d is not used.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The sample rate.</dd>
</dl>
<dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A numpy array where each value is a PCM sample of the sound.</dd>
</dl>
<p>P : A glissando.
V : A musical note with an oscillation of pitch.
N : A basic musical note without vibrato.
T : A tremolo, an oscillation of loudness.
F : Fade in and out.
L : A transition of loudness.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">PV</span><span class="p">())</span>  <span class="c1"># writes file with a glissando and vibrato</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span> <span class="p">[</span><span class="n">AD</span><span class="p">(</span><span class="n">sonic_vector</span><span class="o">=</span><span class="n">PV</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">220</span><span class="p">,</span> <span class="mi">440</span><span class="p">,</span> <span class="mi">4000</span><span class="p">],</span> <span class="p">[</span><span class="mi">440</span><span class="p">,</span> <span class="mi">220</span><span class="p">,</span> <span class="mi">220</span><span class="p">])]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># writes a file with glissandi and vibratos</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.PVV">
<code class="descclassname">music.core.functions.</code><code class="descname">PVV</code><span class="sig-paren">(</span><em>f1=220</em>, <em>f2=440</em>, <em>d=2</em>, <em>fv1=2</em>, <em>fv2=6</em>, <em>nu1=2</em>, <em>nu2=0.5</em>, <em>alpha=1</em>, <em>alphav1=1</em>, <em>alphav2=1</em>, <em>tab=array([-1.</em>, <em>-0.99975586</em>, <em>-0.99951172</em>, <em>...</em>, <em>-0.99951172</em>, <em>-0.99975586</em>, <em>-1.        ])</em>, <em>tabv1=array([ 0.</em>, <em>0.0003835</em>, <em>0.00076699</em>, <em>...</em>, <em>-0.00115049</em>, <em>-0.00076699</em>, <em>-0.0003835 ])</em>, <em>tabv2=array([ 0.</em>, <em>0.0003835</em>, <em>0.00076699</em>, <em>...</em>, <em>-0.00115049</em>, <em>-0.00076699</em>, <em>-0.0003835 ])</em>, <em>nsamples=0</em>, <em>fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.PVV" title="Permalink to this definition">¶</a></dt>
<dd><p>A note with a glissando and a vibrato that also has a secondary oscillatory pattern.</p>
<dl class="docutils">
<dt>f1 <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The starting frequency.</dd>
<dt>f2 <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The final frequency.</dd>
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The duration of the sound in seconds.</dd>
<dt>fv1 <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The frequency of the vibrato.</dd>
<dt>fv2 <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The frequency of the secondary pattern of the vibrato.</dd>
<dt>nu1 <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The maximum deviation of pitch in the vibrato in semitones.</dd>
<dt>nu1 <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The maximum deviation in semitones of pitch in the
secondary pattern of the vibrato.</dd>
<dt>alpha <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>An index to begin the transitions faster or slower. 
If alpha != 1, the transition is not of linear pitch.</dd>
<dt>alphav1 <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>An index to distort the pitch deviation of the vibrato.</dd>
<dt>alphav2 <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>An index to distort the pitch deviation of the 
secondary pattern of the vibrato.</dd>
<dt>tab <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The table with the waveform to synthesize the sound.</dd>
<dt>tabv1 <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The table with the waveform for the vibrato oscillatory pattern.</dd>
<dt>tabv2 <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The table with the waveform for the
secondary pattern of the vibrato.</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The number of samples of the sound.
If supplied, d is not used.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The sample rate.</dd>
</dl>
<dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A numpy array where each value is a PCM sample of the sound.</dd>
</dl>
<p>PV : A note with a glissando and a vibrato.
VV : A note with a vibrato with two oscillatory patterns.
<a href="#id29"><span class="problematic" id="id30">PV_</span></a> : A note with arbitrary pitch transitions and vibratos.
V : a musical note with an oscillation of pitch.
N : a basic musical note without vibrato.
T : a tremolo, an oscillation of loudness.
F : fade in or out.
L : a transition of loudness.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">PVV</span><span class="p">())</span>  <span class="c1"># writes file with a two simultaneous vibratos and a glissando</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span> <span class="p">[</span><span class="n">AD</span><span class="p">(</span><span class="n">sonic_vector</span><span class="o">=</span><span class="n">PVV</span><span class="p">(</span><span class="n">fv2</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">nu1</span><span class="o">=</span><span class="n">j</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">330</span><span class="p">,</span> <span class="mi">440</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">15</span><span class="p">])]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># writes a file with two vibratos and a glissando</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.PV_">
<code class="descclassname">music.core.functions.</code><code class="descname">PV_</code><span class="sig-paren">(</span><em>f=[220, 440, 330], d=[[2, 3], [2, 5, 3], [2, 5, 6, 1, 0.4]], fv=[[2, 6, 1], [0.5, 15, 2, 6, 3]], nu=[[2, 1, 5], [4, 3, 7, 10, 3]], alpha=[[1, 1], [1, 1, 1], [1, 1, 1, 1, 1]], tab=[[array([-1.        , -0.99975586, -0.99951172, ..., -0.99951172,        -0.99975586, -1.        ]), array([-1.        , -0.99975586, -0.99951172, ..., -0.99951172,        -0.99975586, -1.        ])], [array([ 0.        ,  0.0003835 ,  0.00076699, ..., -0.00115049,        -0.00076699, -0.0003835 ]), array([-1.        , -0.99975586, -0.99951172, ..., -0.99951172,        -0.99975586, -1.        ]), array([ 0.        ,  0.0003835 ,  0.00076699, ..., -0.00115049,        -0.00076699, -0.0003835 ])], [array([ 0.        ,  0.0003835 ,  0.00076699, ..., -0.00115049,        -0.00076699, -0.0003835 ]), array([ 0.        ,  0.0003835 ,  0.00076699, ..., -0.00115049,        -0.00076699, -0.0003835 ]), array([ 0.        ,  0.0003835 ,  0.00076699, ..., -0.00115049,        -0.00076699, -0.0003835 ]), array([ 0.        ,  0.0003835 ,  0.00076699, ..., -0.00115049,        -0.00076699, -0.0003835 ]), array([ 0.        ,  0.0003835 ,  0.00076699, ..., -0.00115049,        -0.00076699, -0.0003835 ])]], nsamples=0, fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.PV_" title="Permalink to this definition">¶</a></dt>
<dd><p>A note with an arbitrary sequence of pitch transition and a meta-vibrato.</p>
<p>A meta-vibrato consists in multiple vibratos.
The sequence of pitch transitions is a glissandi.</p>
<dl class="docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">list of lists of scalars</span></dt>
<dd>The frequencies of the note at each end of the transitions.</dd>
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">list of lists of scalars</span></dt>
<dd>The durations of the transitions and then of the vibratos.</dd>
<dt>fv <span class="classifier-delimiter">:</span> <span class="classifier">list of lists of scalars</span></dt>
<dd>The frequencies of each vibrato.</dd>
<dt>nu <span class="classifier-delimiter">:</span> <span class="classifier">list of lists of scalars</span></dt>
<dd>The maximum deviation of pitch in the vibratos in semitones.</dd>
<dt>alpha <span class="classifier-delimiter">:</span> <span class="classifier">list of lists of scalars</span></dt>
<dd>Indexes to distort the pitch deviations of the transitions
and the vibratos.</dd>
<dt>tab <span class="classifier-delimiter">:</span> <span class="classifier">list of lists of array_likes</span></dt>
<dd>The tables with the waveforms to synthesize the sound
and for the oscillatory patterns of the vibratos.
All the tables for f should have the same size.</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The number of samples of the sound.
If supplied, d is not used.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The sample rate.</dd>
</dl>
<dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A numpy array where each value is a PCM sample of the sound.</dd>
</dl>
<p>PV : A note with a glissando and a vibrato.
PVV : A note with a glissando and two vibratos.
VV : A note with a vibrato with two oscillatory patterns.
N : a basic musical note without vibrato.
V : a musical note with an oscillation of pitch.
T : a tremolo, an oscillation of loudness.
F : fade in and out.
L : a transition of loudness.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">PV_</span><span class="p">())</span>  <span class="c1"># writes file with glissandi and vibratos</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.R">
<code class="descclassname">music.core.functions.</code><code class="descname">R</code><span class="sig-paren">(</span><em>d=1.9</em>, <em>d1=0.15</em>, <em>decay=-50</em>, <em>stat='brown'</em>, <em>sonic_vector=0</em>, <em>fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.R" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply an artificial reverberation or return the impulse response.</p>
<dl class="docutils">
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The total duration of the reverberation in seconds.</dd>
<dt>d1 <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The duration of the first phase of the reverberation
in seconds.</dd>
<dt>decay <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The total decay of the last incidence in decibels.</dd>
<dt>stat <span class="classifier-delimiter">:</span> <span class="classifier">string or scalar</span></dt>
<dd>A string or scalar specifying the noise.
Passed to noises(ntype=scalar).</dd>
<dt>sonic_vector <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>An optional one dimensional array for the reverberation to
be applied.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The sampling frequency.</dd>
</dl>
<dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>An array if the impulse response of the reverberation
(if sonic_vector is not specified),
or with the reverberation applied to sonic_vector.</dd>
</dl>
<p>This is a simple artificial reverberation with a progressive
loudness decay of the reincidences of the sound and with
two periods: the first consists of scattered reincidences,
the second period reincidences is modeled by a noise.</p>
<p>Comparing with the description in [1], the frequency bands
are ignored.</p>
<p>One might want to run this function twice to obtain
a stereo reverberation.</p>
<p>Cite the following article whenever you use this function.</p>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Fabbri, Renato, et al. “Musical elements in the</td></tr>
</tbody>
</table>
<p>discrete-time representation of sound.”
arXiv preprint arXiv:abs/1412.6853 (2017)</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.T">
<code class="descclassname">music.core.functions.</code><code class="descname">T</code><span class="sig-paren">(</span><em>d=2</em>, <em>fa=2</em>, <em>dB=10</em>, <em>alpha=1</em>, <em>taba=array([ 0.</em>, <em>0.0003835</em>, <em>0.00076699</em>, <em>...</em>, <em>-0.00115049</em>, <em>-0.00076699</em>, <em>-0.0003835 ])</em>, <em>nsamples=0</em>, <em>sonic_vector=0</em>, <em>fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.T" title="Permalink to this definition">¶</a></dt>
<dd><p>Synthesize a tremolo envelope or apply it to a sound.</p>
<p>Set fa=0 or dB=0 for a constant envelope with value 1.
A tremolo is an oscillatory pattern of loudness [1].</p>
<dl class="docutils">
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The duration of the envelope in seconds.</dd>
<dt>fa <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The frequency of the tremolo oscillations in Hertz.</dd>
<dt>dB <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The maximum deviation of loudness in the tremolo in decibels.</dd>
<dt>alpha <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>An index to distort the tremolo pattern [1].</dd>
<dt>taba <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The table with the waveform for the tremolo oscillatory pattern.</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The number of samples of the envelope. If supplied, d is ignored.</dd>
<dt>sonic_vector <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Samples for the tremolo to be applied to.
If supplied, d and nsamples are ignored.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The sample rate.</dd>
</dl>
<dl class="docutils">
<dt>T <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A numpy array where each value is a PCM sample
of the envelope.
if sonic_vector is 0.
If sonic_vector is input,
T is the sonic vector with the tremolo applied to it.</dd>
</dl>
<p>V : A musical note with an oscillation of pitch.
FM : A linear oscillation of fundamental frequency.
AM : A linear oscillation of amplitude.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">V</span><span class="p">()</span><span class="o">*</span><span class="n">T</span><span class="p">())</span>  <span class="c1"># writes a WAV file of a note with tremolo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span> <span class="p">[</span><span class="n">V</span><span class="p">()</span><span class="o">*</span><span class="n">T</span><span class="p">(</span><span class="n">fa</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">dB</span><span class="o">=</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">])]</span> <span class="p">)</span>  <span class="c1"># OR</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span> <span class="p">[</span><span class="n">T</span><span class="p">(</span><span class="n">fa</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">dB</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">sonic_vector</span><span class="o">=</span><span class="n">V</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">])]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">envelope2</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mi">440</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>  <span class="c1"># a lengthy envelope</span>
</pre></div>
</div>
<p>In the MASS framework implementation, for obtaining a sound with a tremolo (or AM),
the tremolo pattern is considered separately from a synthesis of the sound.</p>
<p>The vibrato and FM patterns are considering when synthesizing the sound.</p>
<p>Cite the following article whenever you use this function.</p>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Fabbri, Renato, et al. “Musical elements in the</td></tr>
</tbody>
</table>
<p>discrete-time representation of sound.” arXiv preprint arXiv:abs/1412.6853 (2017)</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.T_">
<code class="descclassname">music.core.functions.</code><code class="descname">T_</code><span class="sig-paren">(</span><em>d=[[3, 4, 5], [2, 3, 7, 4]], fa=[[2, 6, 20], [5, 6.2, 21, 5]], dB=[[10, 20, 1], [5, 7, 9, 2]], alpha=[[1, 1, 1], [1, 1, 1, 9]], taba=[[array([ 0.        ,  0.0003835 ,  0.00076699, ..., -0.00115049,        -0.00076699, -0.0003835 ]), array([ 0.        ,  0.0003835 ,  0.00076699, ..., -0.00115049,        -0.00076699, -0.0003835 ]), array([ 0.        ,  0.0003835 ,  0.00076699, ..., -0.00115049,        -0.00076699, -0.0003835 ])], [array([-1.        , -0.99975586, -0.99951172, ..., -0.99951172,        -0.99975586, -1.        ]), array([-1.        , -0.99975586, -0.99951172, ..., -0.99951172,        -0.99975586, -1.        ]), array([-1.        , -0.99975586, -0.99951172, ..., -0.99951172,        -0.99975586, -1.        ]), array([ 0.        ,  0.0003835 ,  0.00076699, ..., -0.00115049,        -0.00076699, -0.0003835 ])]], nsamples=0, sonic_vector=0, fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.T_" title="Permalink to this definition">¶</a></dt>
<dd><p>An envelope with multiple tremolos.</p>
<dl class="docutils">
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">iterable of iterable of scalars</span></dt>
<dd>the durations of each tremolo.</dd>
<dt>fa <span class="classifier-delimiter">:</span> <span class="classifier">iterable of iterable of scalars</span></dt>
<dd>The frequencies of each tremolo.</dd>
<dt>dB <span class="classifier-delimiter">:</span> <span class="classifier">iterable of iterable of scalars</span></dt>
<dd>The maximum loudness variation
of each tremolo.</dd>
<dt>alpha <span class="classifier-delimiter">:</span> <span class="classifier">iterable of iterable of scalars</span></dt>
<dd>Indexes for distortion of each tremolo [1].</dd>
<dt>taba <span class="classifier-delimiter">:</span> <span class="classifier">iterable of iterable of array_likes</span></dt>
<dd>Tables for lookup for each tremolo.</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">iterable of iterable of scalars</span></dt>
<dd>The number of samples or each tremolo.</dd>
<dt>sonic_vector <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The sound to which apply the tremolos.
If supplied, the tremolo lines are
applied to the sound and missing samples
are completed by zeros (if sonic_vector
is smaller then the lengthiest tremolo)
or ones (is sonic_vector is larger).</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The sample rate</dd>
</dl>
<dl class="docutils">
<dt>E <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A numpy array where each value is a value of the envelope
for the PCM samples.
If sonic_vector is supplied,
E is the sonic vector with the envelope applied to it.</dd>
</dl>
<p>L : An envelope for a loudness transition.
<a href="#id31"><span class="problematic" id="id32">L_</span></a> : An envelope with an arbitrary number of transitions.
F : Fade in and out.
AD : An ADSR envelope.
T : An oscillation of loudness.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">V</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span><span class="o">*</span><span class="n">L_</span><span class="p">())</span>  <span class="c1"># writes a WAV file with a loudness transitions</span>
</pre></div>
</div>
<p>Cite the following article whenever you use this function.</p>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Fabbri, Renato, et al. “Musical elements in the discrete-time representation of sound.” arXiv preprint arXiv:abs/1412.6853 (2017)</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.V">
<code class="descclassname">music.core.functions.</code><code class="descname">V</code><span class="sig-paren">(</span><em>f=220</em>, <em>d=2</em>, <em>fv=4</em>, <em>nu=2</em>, <em>tab=array([-1.</em>, <em>-0.99975586</em>, <em>-0.99951172</em>, <em>...</em>, <em>-0.99951172</em>, <em>-0.99975586</em>, <em>-1.        ])</em>, <em>tabv=array([ 0.</em>, <em>0.0003835</em>, <em>0.00076699</em>, <em>...</em>, <em>-0.00115049</em>, <em>-0.00076699</em>, <em>-0.0003835 ])</em>, <em>alpha=1</em>, <em>nsamples=0</em>, <em>fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.V" title="Permalink to this definition">¶</a></dt>
<dd><p>Synthesize a musical note with a vibrato.</p>
<p>Set fv=0 or nu=0 (or use N()) for a note without vibrato.
A vibrato is an oscillatory pattern of pitch [1].</p>
<dl class="docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The frequency of the note in Hertz.</dd>
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The duration of the note in seconds.</dd>
<dt>fv <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The frequency of the vibrato oscillations in Hertz.</dd>
<dt>nu <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The maximum deviation of pitch in the vibrato in semitones.</dd>
<dt>tab <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The table with the waveform to synthesize the sound.</dd>
<dt>tabv <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The table with the waveform for the vibrato oscillatory pattern.</dd>
<dt>alpha <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>An index to distort the vibrato [1]. 
If alpha != 1, the vibrato is not of linear pitch.</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The number of samples in the sound.
If supplied, d is ignored.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The sample rate.</dd>
</dl>
<dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A numpy array where each value is a PCM sample of the note.</dd>
</dl>
<p>N : A basic musical note without vibrato.
T : A tremolo, an oscillation of loudness.
FM : A linear oscillation of the frequency (not linear pitch).
AM : A linear oscillation of amplitude (not linear loudness).
<a href="#id33"><span class="problematic" id="id34">V_</span></a> : A shorthand to render a note with vibrato using</p>
<blockquote>
<div>a reference frequency and a pitch interval.</div></blockquote>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">V</span><span class="p">())</span>  <span class="c1"># writes a WAV file of a note</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span> <span class="p">[</span><span class="n">V</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">200</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">V</span><span class="p">(</span><span class="mi">440</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In the MASS framework implementation,
for a sound with a vibrato (or FM) to be synthesized using LUT,
the vibrato pattern is considered when performing the lookup calculations.</p>
<p>The tremolo and AM patterns are implemented as separate amplitude envelopes.</p>
<p>Cite the following article whenever you use this function.</p>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Fabbri, Renato, et al. “Musical elements in the</td></tr>
</tbody>
</table>
<p>discrete-time representation of sound.” arXiv preprint arXiv:abs/1412.6853 (2017)</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.VV">
<code class="descclassname">music.core.functions.</code><code class="descname">VV</code><span class="sig-paren">(</span><em>f=220</em>, <em>d=2</em>, <em>fv1=2</em>, <em>fv2=6</em>, <em>nu1=2</em>, <em>nu2=4</em>, <em>alphav1=1</em>, <em>alphav2=1</em>, <em>tab=array([-1.</em>, <em>-0.99975586</em>, <em>-0.99951172</em>, <em>...</em>, <em>-0.99951172</em>, <em>-0.99975586</em>, <em>-1.        ])</em>, <em>tabv1=array([ 0.</em>, <em>0.0003835</em>, <em>0.00076699</em>, <em>...</em>, <em>-0.00115049</em>, <em>-0.00076699</em>, <em>-0.0003835 ])</em>, <em>tabv2=array([ 0.</em>, <em>0.0003835</em>, <em>0.00076699</em>, <em>...</em>, <em>-0.00115049</em>, <em>-0.00076699</em>, <em>-0.0003835 ])</em>, <em>nsamples=0</em>, <em>fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.VV" title="Permalink to this definition">¶</a></dt>
<dd><p>A note with a vibrato that also has a secondary oscillatory pattern.</p>
<dl class="docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The frequency of the note.</dd>
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The duration of the sound in seconds.</dd>
<dt>fv1 <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The frequency of the vibrato.</dd>
<dt>fv2 <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The frequency of the secondary pattern of the vibrato.</dd>
<dt>nu1 <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The maximum deviation of pitch in the vibrato in semitones.</dd>
<dt>nu2 <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The maximum deviation in semitones of pitch in the
secondary pattern of the vibrato.</dd>
<dt>alphav1 <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>An index to distort the pitch deviation of the vibrato.</dd>
<dt>alphav2 <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>An index to distort the pitch deviation of the 
secondary pattern of the vibrato.</dd>
<dt>tab <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The table with the waveform to synthesize the sound.</dd>
<dt>tabv1 <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The table with the waveform for the vibrato oscillatory pattern.</dd>
<dt>tabv2 <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The table with the waveform for the
secondary pattern of the vibrato.</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The number of samples of the sound.
If supplied, d is not used.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The sample rate.</dd>
</dl>
<dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A numpy array where each value is a PCM sample of the sound.</dd>
</dl>
<p>PV : A note with a glissando and a vibrato.
PVV : A note with a glissando and a vibrato with two oscillatory patterns.
N : A basic musical note without vibrato.
V : A musical note with an oscillation of pitch.
T : A tremolo, an oscillation of loudness.
F : Fade in and out.
L : A transition of loudness.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">VV</span><span class="p">())</span>  <span class="c1"># writes file with a two simultaneous vibratos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span> <span class="p">[</span><span class="n">AD</span><span class="p">(</span><span class="n">sonic_vector</span><span class="o">=</span><span class="n">VV</span><span class="p">(</span><span class="n">fv1</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">fv2</span><span class="o">=</span><span class="n">j</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">])]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># writes a file with two vibratos</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.W">
<code class="descclassname">music.core.functions.</code><code class="descname">W</code><span class="sig-paren">(</span><em>sonic_vector=array([ 0.35356651</em>, <em>0.96444061</em>, <em>0.11645631</em>, <em>...</em>, <em>0.15844934</em>, <em>0.38238774</em>, <em>0.22731215])</em>, <em>filename='asound.wav'</em>, <em>fs=44100</em>, <em>fades=0</em>, <em>bit_depth=16</em>, <em>remove_bias=True</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.W" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a mono WAV file for a numpy array.</p>
<dl class="docutils">
<dt>One can also use, for example:</dt>
<dd>import sounddevice as S
S.play(__n(array))</dd>
</dl>
<dl class="docutils">
<dt>sonic_vector <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The PCM samples to be written as a WAV sound file.
The samples are always normalized by __n(sonic_vector)
to have samples between -1 and 1.</dd>
<dt>filename <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The filename to use for the file to be written.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The sample frequency.</dd>
<dt>fades <span class="classifier-delimiter">:</span> <span class="classifier">interable</span></dt>
<dd>An iterable with two values for the milliseconds you
want for the fade in and out (to avoid clicks).</dd>
<dt>bit_depth <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The number of bits in each sample of the final file.</dd>
<dt>remove_bias <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>Whether to remove or not the bias (or offset)</dd>
</dl>
<p>__n : Normalizes an array to [-1,1]
<a href="#id35"><span class="problematic" id="id36">W_</span></a> : Writes an array with the same arguments
and order of them as scipy.io.wavfile.
WS ; Write a stereo file.</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.WS">
<code class="descclassname">music.core.functions.</code><code class="descname">WS</code><span class="sig-paren">(</span><em>sonic_vector=array([[ 0.92956207,  0.17481337,  0.49301615, ...,  0.26537058,          0.84012122,  0.84421445],        [ 0.36646579,  0.644846  ,  0.12506887, ...,  0.04606155,          0.97674495,  0.68533196]]), filename='asound.wav', fs=44100, fades=0, bit_depth=16, remove_bias=True, normalize_sep=False</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.WS" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a stereo WAV files for a numpy array.</p>
<dl class="docutils">
<dt>sonic_vector <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The PCM samples to be written as a WAV sound file.
The samples are always normalized by __n(sonic_vector)
to have samples between -1 and 1 and remove the offset.
Use array of shape (nchannels, nsamples).</dd>
<dt>filename <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The filename to use for the file to be written.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The sample frequency.</dd>
<dt>fades <span class="classifier-delimiter">:</span> <span class="classifier">interable</span></dt>
<dd>An iterable with two values for the milliseconds you
want for the fade in and out (to avoid clicks).</dd>
<dt>bit_depth <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The number of bits in each sample of the final file.</dd>
<dt>remove_bias <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>Whether to remove or not the bias (or offset)</dd>
<dt>normalize_sep <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>Set to True if each channel should be normalized
separately. If False (default), the arrays will be
rescaled in the same proportion.</dd>
</dl>
<p>__ns : Normalizes a stereo array to [-1,1]
W ; Write a mono file.</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.W_">
<code class="descclassname">music.core.functions.</code><code class="descname">W_</code><span class="sig-paren">(</span><em>fn</em>, <em>fs</em>, <em>sa</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.W_" title="Permalink to this definition">¶</a></dt>
<dd><p>To mimic scipy.io.wavefile input</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.convolve">
<code class="descclassname">music.core.functions.</code><code class="descname">convolve</code><span class="sig-paren">(</span><em>sig1</em>, <em>sig2</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.convolve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="music.core.functions.loc">
<code class="descclassname">music.core.functions.</code><code class="descname">loc</code><span class="sig-paren">(</span><em>sonic_vector=array([-1.</em>, <em>-0.98022461</em>, <em>-0.96020508</em>, <em>...</em>, <em>-0.94018555</em>, <em>-0.96020508</em>, <em>-0.98022461])</em>, <em>theta=0</em>, <em>dist=0</em>, <em>x=0.1</em>, <em>y=0.01</em>, <em>zeta=0.215</em>, <em>temp=20</em>, <em>fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.loc" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a mono sound stereo and localize it by a very naive method.</p>
<p>See bellow for implementation notes.</p>
<dl class="docutils">
<dt>sonic_vector <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>An one dimensional with the PCM samples of the sound.</dd>
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The lateral component of the position in meters.</dd>
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The frontal component of the position in meters.</dd>
<dt>theta <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The azimuthal angle of the position in degrees.
If theta is supplied, x and y are ignored
and dist must also be supplied
for the sound localization to have effect.</dd>
<dt>dist <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The distance of the source from the listener
in meters.</dd>
<dt>zeta <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The distance between the ears in meters.</dd>
<dt>temp <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The temperature in Celsius used for calculating
the speed of sound.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The sample rate.</dd>
</dl>
<dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A (2, nsamples) shaped array with the PCM
samples of the stereo sound.</dd>
</dl>
<p>R : A reverberator.
<a href="#id37"><span class="problematic" id="id38">loc_</span></a> : a less naive implementation of localization
by ITD and IID.
hrtf : performs localization by means of a
Head Related Transfer Function.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">WS</span><span class="p">(</span><span class="n">loc</span><span class="p">())</span>  <span class="c1"># write a soundfile that is localized</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">WS</span><span class="p">(</span><span class="n">H</span><span class="p">([</span><span class="n">loc</span><span class="p">(</span><span class="n">V</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">x</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span>
<span class="gp">... </span>  <span class="nb">zip</span><span class="p">([</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span><span class="o">.</span><span class="mi">7</span><span class="p">,</span><span class="n">n</span><span class="o">.</span><span class="n">pi</span><span class="o">-.</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">.</span><span class="n">pi</span><span class="o">-.</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span><span class="o">.</span><span class="mi">1</span><span class="p">])]))</span>
</pre></div>
</div>
<p>Uses the most naive ITD and IID calculations as described in [1].
A less naive method is implemented in loc_().
Nonetheless, if dist is small enough (e.g. &lt;.3),
the perception of theta occurs and might be used.
The advantages of this method are:</p>
<blockquote>
<div><ul class="simple">
<li>It is fast.</li>
<li>It is simple.</li>
<li>It is true to sound propagation phenomenon</li>
</ul>
<p>(although it does not consider the human body
beyond the localization of the ears).
- It can be used easily for tweaks
(such as for a moving source resulting
in a Doppler Effect).</p>
</div></blockquote>
<p>When az = tan^{-1}(y/x) lies in the ‘cone of confusion’,
many values of x and y have the same ITD and IID [1].
Furthermore, lateral sources have the low frequencies
diffracted and reach the opposite ear with a delay
of ~0.7s [1].
The height of a source and if it is in front or
behind a listener are cues given by te HRTF [1].
These issues are not taken into account in this
function.</p>
<p>The value of zeta is ~0.215 for adult humans [1].</p>
<p>This implementation assumes that the speed
of sound (in air) is s = 331.3+0.606*temp.</p>
<p>Cite the following article whenever you use this function.</p>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Fabbri, Renato, et al. “Musical elements in the</td></tr>
</tbody>
</table>
<p>discrete-time representation of sound.” arXiv preprint arXiv:abs/1412.6853 (2017)</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.loc2">
<code class="descclassname">music.core.functions.</code><code class="descname">loc2</code><span class="sig-paren">(</span><em>sonic_vector=array([-1.</em>, <em>-0.98022461</em>, <em>-0.96020508</em>, <em>...</em>, <em>-0.94018555</em>, <em>-0.96020508</em>, <em>-0.98022461])</em>, <em>theta1=90</em>, <em>theta2=0</em>, <em>dist1=0.1</em>, <em>dist2=0.1</em>, <em>zeta=0.215</em>, <em>temp=20</em>, <em>fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.loc2" title="Permalink to this definition">¶</a></dt>
<dd><p>A linear variation of localization</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.loc_">
<code class="descclassname">music.core.functions.</code><code class="descname">loc_</code><span class="sig-paren">(</span><em>sonic_vector=array([-1.</em>, <em>-0.98022461</em>, <em>-0.96020508</em>, <em>...</em>, <em>-0.94018555</em>, <em>-0.96020508</em>, <em>-0.98022461])</em>, <em>theta=-70</em>, <em>x=0.1</em>, <em>y=0.01</em>, <em>zeta=0.215</em>, <em>temp=20</em>, <em>method='ifft'</em>, <em>fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.loc_" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a mono sound stereo and localize it by experimental methods.</p>
<p>See bellow for implementation notes.
These implementations are not standard and are only
to illustrate the method of using ITD and IID
that are frequency dependent.</p>
<dl class="docutils">
<dt>sonic_vector <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>An one dimensional with the PCM samples of the sound.</dd>
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The lateral component of the position in meters.</dd>
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The frontal component of the position in meters.</dd>
<dt>theta <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The azimuthal angle of the position in degrees.
If theta is supplied, x and y are ignored
and dist must also be supplied
for the sound localization to have effect.</dd>
<dt>dist <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The distance of the source from the listener
in meters.</dd>
<dt>zeta <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The distance between the ears in meters.</dd>
<dt>temp <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The temperature in Celsius used for calculating
the speed of sound.</dd>
<dt>method <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Set to “ifft” for a working method that changes the
fourier spectral coefficients.
Set to “brute” for using an implementation that
sinthesizes each sinusoid in the fourier spectrum
separately (currently not giving good results for
all sounds).</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The sample rate.</dd>
</dl>
<dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A (2, nsamples) shaped array with the PCM
samples of the stereo sound.</dd>
</dl>
<p>R : A reverberator.
loc : a more naive and fast implementation of localization
by ITD and IID.
hrtf : performs localization by means of a
Head Related Transfer Function.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">WS</span><span class="p">(</span><span class="n">loc_</span><span class="p">())</span>  <span class="c1"># write a soundfile that is localized</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">WS</span><span class="p">(</span><span class="n">H</span><span class="p">([</span><span class="n">loc_</span><span class="p">(</span><span class="n">V</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">x</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span>
<span class="gp">... </span>  <span class="nb">zip</span><span class="p">([</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span><span class="o">.</span><span class="mi">7</span><span class="p">,</span><span class="n">n</span><span class="o">.</span><span class="n">pi</span><span class="o">-.</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">.</span><span class="n">pi</span><span class="o">-.</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span><span class="o">.</span><span class="mi">1</span><span class="p">])]))</span>
</pre></div>
</div>
<p>Uses a less naive ITD and IID calculations as described in [1].</p>
<p>See loc() for further notes.</p>
<p>Cite the following article whenever you use this function.</p>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Fabbri, Renato, et al. “Musical elements in the</td></tr>
</tbody>
</table>
<p>discrete-time representation of sound.” arXiv preprint arXiv:abs/1412.6853 (2017)</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.noises">
<code class="descclassname">music.core.functions.</code><code class="descname">noises</code><span class="sig-paren">(</span><em>ntype='brown'</em>, <em>d=2</em>, <em>fmin=15</em>, <em>fmax=15000</em>, <em>nsamples=0</em>, <em>fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.noises" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a colored or user-refined noise.</p>
<dl class="docutils">
<dt>ntype <span class="classifier-delimiter">:</span> <span class="classifier">string or scalar</span></dt>
<dd><p class="first">Specifies the decibels gain or attenuation per octave.
It can be specified numerically 
(e.g. ntype=3.5 is 3.5 decibels gain per octave)
or by strings:</p>
<blockquote>
<div>“brown” is -6dB/octave
“pink” is -3dB/octave
“white” is 0dB/octave
“blue” is 3dB/octave
“violet” is 6dB/octave
“black” is -12/dB/octave but, in theory, is any &lt; -6dB/octave</div></blockquote>
<p class="last">See [1] for more information.</p>
</dd>
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The duration of the noise in seconds.</dd>
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">scalar in [0, fs/2]</span></dt>
<dd>The lowest frequency allowed.</dd>
<dt>fmax <span class="classifier-delimiter">:</span> <span class="classifier">scalar in [0, fs/2]</span></dt>
<dd>The highest frequency allowed.
It should be &gt; fmin.</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The number of samples of the resulting sonic vector.</dd>
</dl>
<p>The noise is synthesized with components with random phases,
with the moduli that are related to the decibels/octave,
and with a frequency resolution of</p>
<blockquote>
<div>fs/nsamples = fs/(fs*d) = 1/d Hz</div></blockquote>
<p>Cite the following article whenever you use this function.</p>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Fabbri, Renato, et al. “Musical elements in the</td></tr>
</tbody>
</table>
<p>discrete-time representation of sound.”
arXiv preprint arXiv:abs/1412.6853 (2017)</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.rhythymToDurations">
<code class="descclassname">music.core.functions.</code><code class="descname">rhythymToDurations</code><span class="sig-paren">(</span><em>durations=[4, 2, 2, 4, 1, 1, 1, 1, 2, 2, 4], frequencies=None, duration=0.25, BPM=None, total_duration=None</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.rhythymToDurations" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns durations from rhythmic patterns.</p>
<dl class="docutils">
<dt>durations <span class="classifier-delimiter">:</span> <span class="classifier">interable of scalars</span></dt>
<dd>The relative durations of each item (e.g. note).</dd>
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">iterable of scalars</span></dt>
<dd>The number of the entry’s duration that fits into the pulse.
If supplied, durations is ignored.</dd>
<dt>duration <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>A basic duration (e.g. for the pulse) in seconds.</dd>
<dt>BPM <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The number of beats per second.
If supplied, duration is ignored.</dd>
<dt>total_duration: scalar</dt>
<dd>The total duration of the sequence in seconds.
If supplied, both BPM and duration are ignored.</dd>
</dl>
<p>durs : List of durations in seconds.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durs0</span> <span class="o">=</span> <span class="n">rhythymToDurations</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">duration</span><span class="o">=.</span><span class="mi">25</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durs0_</span> <span class="o">=</span> <span class="n">rhythymToDurations</span><span class="p">(</span><span class="n">frequencies</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dtut</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durs1</span> <span class="o">=</span> <span class="n">rhythymToDurations</span><span class="p">(</span><span class="n">dtut</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dtuf2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="mi">16</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durs1_</span> <span class="o">=</span> <span class="n">rhythymToDurations</span><span class="p">(</span><span class="n">frequencies</span><span class="o">=</span><span class="n">dtut2</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>The durations parameter is considered to be in a temporal notation
for durations/rhythm: each entry is a relative duration to
be multiplied by the base duration given through duration,
BPM or total_duration.
&gt;&gt;&gt; durs = [i*duration for i in durations]</p>
<p>The frequencies parameter is considered to be in a
frequential notation: each entry is the number of the
entry that fits a same duration (also given through duration,
BPM or total_duration).
&gt;&gt;&gt; durs = [duration/i for i in frequencies]</p>
<p>The examples above yield (two by two) the same sequences of durations
by using duration=0.25 when in temporal notation or
duration=4 when in frequency notation.</p>
<p>To facilitate the description of rhythms (e.g. for tuplets),
some set of durations might be an iterable inside durations
or frequencies. In this case:</p>
<blockquote>
<div><dl class="docutils">
<dt>### if mode is temporal:</dt>
<dd>total_dur = cell[0]*duration
# durations are proportional to remaining values:
<a href="#id39"><span class="problematic" id="id40">d_</span></a> = [i/sum(cell[1:]) for i in cell[1:]]
durs = [i*total_dur for i in <a href="#id41"><span class="problematic" id="id42">d_</span></a>]</dd>
<dt>### if mode is frequential:</dt>
<dd>total_dur = duration/cell[0]
# durations are inversely proportional to remaining values:
<a href="#id43"><span class="problematic" id="id44">d_</span></a> = [i/sum(cell[1:]) for i in cell[1:]]
durs = [i*total_dur for i in <a href="#id45"><span class="problematic" id="id46">d_</span></a>]</dd>
</dl>
</div></blockquote>
<p>An example for achieving the same sequence of durations through
temporal or frequential notation and with cells for tuplets
is the last two sequences of the examples.</p>
<dl class="docutils">
<dt>It might be a good idea to incorporate also this notation:</dt>
<dd>d2 = [1, 4, 1, 4]  # [quarter note + 4 sixteenth notes] x 2</dd>
</dl>
<p>Cite the following article whenever you use this function.</p>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Fabbri, Renato, et al. “Musical elements in the</td></tr>
</tbody>
</table>
<p>discrete-time representation of sound.” arXiv preprint arXiv:abs/1412.6853 (2017)</p>
</dd></dl>

<dl class="function">
<dt id="music.core.functions.trill">
<code class="descclassname">music.core.functions.</code><code class="descname">trill</code><span class="sig-paren">(</span><em>f=[440, 493.8833012561241], ft=17, d=5, fs=44100</em><span class="sig-paren">)</span><a class="headerlink" href="#music.core.functions.trill" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a trill.</p>
<p>This is just a simple function for exemplifying
the synthesis of trills.
The user is encouraged to make its own functions
for trills and set e.g. ADSR envelopes, tremolos
and vibratos as intended.</p>
<dl class="docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">iterable of scalars</span></dt>
<dd>Frequencies to the iterated.</dd>
<dt>ft <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The number of notes per second.</dd>
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The maximum duration of the trill in seconds.</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>The sample rate.</dd>
</dl>
<p>V : A note with vibrato.
<a href="#id47"><span class="problematic" id="id48">PV_</span></a> : a note with an arbitrary sequence of pitch transition and a meta-vibrato.
T : A tremolo envelope.</p>
<dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The PCM samples of the resulting sound.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">(</span><span class="n">trill</span><span class="p">())</span>
</pre></div>
</div>
<p>Cite the following article whenever you use this function.</p>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Fabbri, Renato, et al. “Musical elements in the</td></tr>
</tbody>
</table>
<p>discrete-time representation of sound.” arXiv preprint arXiv:abs/1412.6853 (2017)</p>
</dd></dl>

</div>
<div class="section" id="music-core-synths-module">
<h2>music.core.synths module<a class="headerlink" href="#music-core-synths-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-music.core">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-music.core" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Renato fabbri.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/music.core.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>